---
title: Leetcode初级算法笔记
tags: ["Leetcode","C++"]
---

## 概述：

Leetcode 官方推出了经典面试题目清单，并将其重新整理规划，将其分为一下三个部分：

1. [初级算法 - 帮助入门](https://leetcode-cn.com/leetbook/detail/top-interview-questions-easy/)
2. [中级算法 - 巩固训练](https://leetcode-cn.com/leetbook/detail/top-interview-questions-medium/)
3. [高级算法 - 提升进阶](https://leetcode-cn.com/leetbook/detail/top-interview-questions-hard/)

然后这篇笔记就是我开的一篇新坑，记录自己在初级算法题目清单中的个人笔记。后续应该也会写中级算法和高级算法。

## 数组

### 1.删除排序数组中的重复项

要求在 O(1) 额外空间的条件下，原地删除重复出现的元素。

思路：这题采取<b>双指针</b>的思路。指针 i 用于建立删除重复项之后的数组，标记当前已经剔除重复项的元素存放的位置，指针 j 用来遍历原数组寻找重复项。i 初始化为 0 ，j 初始化为 1，当 nums[j] != nums[i] 时，nums[++i] = nums[j]，也就是把剔除重复想的元素放到新数组的相应位置；因为原数组是有序的，所以重复项是连续的，当 nums[j] == nums[i] 时，直接跳过。

~~~c++
class Solution {
public:
    int removeDuplicates(vector<int>& nums) {
        if (nums.empty()) 
            return 0;
        int i = 0;
        for (int j = 1; j < nums.size(); j++)
            if (nums[j] != nums[i])
                nums[++i] = nums[j];
        return i + 1;
    }
};
~~~

* 时间复杂度：O(n)
* 空间复杂度：O(1)

#### 双指针

既然提到了双指针，这里我们就详细讲一下双指针的思想。双指针通常用在**线性的数据结构**中，比如链表和数组，有时候也会用在图算法中。双指针主要分为**快慢指针**和**左右指针**。

1. 快慢指针

两个指针从链表的同一节点出发，其中一个指针前进速度比另一个指针快。利用快慢指针可以用来解决某些算法问题，比如：

* 计算链表的中点：快慢指针从头节点出发，每轮迭代中，快指针向前移动两个节点，慢指针向前移动一个节点，最终当快指针到达终点的时候，慢指针刚好在中间的节点。
* 判断链表是否有环：如果链表中存在环，则在链表上不断前进的指针会一直在环里绕圈子，且不能知道链表是否有环。使用快慢指针，当链表中存在环时，两个指针最终会在环中相遇。
* 判断链表中环的起点：当我们判断出链表中存在环，并且知道了两个指针相遇的节点，我们可以让其中任一个指针指向头节点，然后让它俩以相同速度前进，再次相遇时所在的节点位置就是环开始的位置。
* 求链表中环的长度：只要相遇后一个不动，另一个前进直到相遇算一下走了多少步就好了
* 求链表倒数第k个元素：先让其中一个指针向前走k步，接着两个指针以同样的速度一起向前进，直到前面的指针走到尽头了，则后面的指针即为倒数第k个元素。

![avatar](https://github.com/QingJun3/QingJun3.github.io/blob/master/_posts/img/142_fig1.png?raw=true)

2. 左右指针

一般都是**排好序的数组或链表**，否则无序的话这两个指针的位置也没有什么意义。一般将指向最左侧的索引定义为左指针，最右侧的定义为右指针，然后从两头向中间进行遍历。利用左右指针可以用来解决某些算法问题，比如：

* 二分查找问题
* n数之和问题：比如两数之和问题，先对数组排序然后左右指针找到满足条件的两个数。如果是三数问题就转化为一个数和另外两个数的两数问题。以此类推。
* 滑动窗口：两个指针，一前一后组成滑动窗口，并计算滑动窗口中的元素的问题。这类问题一般包括：
  * 字符串匹配问题
  * 子数组问题